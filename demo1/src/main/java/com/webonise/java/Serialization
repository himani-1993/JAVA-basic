Serializzation
- Actual state to byte streams

* If Super class implements Serializable then sub class are also Serializable automatically.

* If Super class is not serializable then when sub class is de serialized then super class’s default constructor will be
 invoked. Hence all variable will get default value and reference will be null.
 If a class has implemented Serializable interface then state of this class can be saved. But if same class extend
 another class which didn’t implement Serializable interface then Super class’s state will not be saved.


What happens in reality

Algo

 - write description of class cOb to which object belongs say ob written in writeObject().
 - write desc of its parent class of cOb
 - write data associated with the object ob
 - write desc of objects say ob1 defined in cOb class
 - write data associated with the objects eg ob1, ob2


Serial version ID-

    - SerialVersionUID is used for version control of object.
    - Consequence of not specifying serialVersionUID is that when you add or modify any field in class then already serialized class will not be able to recover because serialVersionUID generated for new class and for old serialized object will be different.
      Read more: http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz4YkrPktAT


      ** Array classes cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for matching serialVersionUID values is waived for array classes.


Transient and Static:

    - If you don't want any field to be part of object's state then declare it either static or transient based on your need and it will not be included during Java serialization process.

    - Static variables value can be stored while serializing if the same is provided while initialization.

    - If variable is defined as Static and Transient both, than static modifier will govern the behavior of variable and not Transient.

    http://javabeginnerstutorial.com/core-java-tutorial/transient-vs-static-variable-java/


*   If you try to serialize an object of a class which implements Serializable, but the object includes a reference to an non- Serializable class then a ‘NotSerializableException’ will be thrown at runtime and this is why I always put a SerializableAlert


*   If Super class is Serialized and if you don't want to implement serialization in sub-class:
    To avoid Java serialization you need to implement writeObject() and readObject() method in your Class and need to
    throw NotSerializableException from those method.


